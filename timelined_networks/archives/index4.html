<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTRPG Citation Timeline</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        input[type="text"] {
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            width: 200px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        button {
            padding: 12px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 10px;
            min-height: 20px;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }

        #network-container {
            width: 100%;
            height: 800px;
            border: 2px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            background: #fafafa;
            position: relative;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .node text {
            font-size: 11px;
            font-family: 'Segoe UI', sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            fill: none;
        }

        .link.highlighted {
            stroke: #ff6b35;
            stroke-opacity: 0.8;
            stroke-width: 1px;
        }

        .link.backward-citation {
            stroke: #ff6b35;
            stroke-opacity: 0.8;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            word-wrap: break-word;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            flex-wrap: wrap;
        }

        .layout-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            border-radius: 20px;
            background: white;
            color: #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: #667eea;
            color: white;
        }

        .timeline-axis {
            stroke: #666;
            stroke-width: 2;
        }

        .timeline-tick {
            stroke: #999;
            stroke-width: 1;
        }

        .timeline-label {
            font-size: 12px;
            fill: #666;
            text-anchor: middle;
        }

        .decade-separator {
            stroke: #ddd;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }
    </style>
</head>
<body>
<div class="container">
        <h1>üìÖ TTRPG Citation Timeline Network</h1>
        
        <p>Submit the Wikidata QID of a tabletop role-playing game (for example Q112134730 is <i>Apocalypse World, 1st ed.</i>, by Vincent Baker). 
		Explore the timeline of citations between games and see how influence flows through RPG history.</p>
        
        <div class="controls">
            <input type="text" id="qid-input" placeholder="Enter QID (e.g., Q112134730)" value="Q112134730">
            <input type="number" id="max-depth" placeholder="Max depth" min="1" max="15" value="4">
            <button onclick="buildNetwork()">üîç Build Citation Network</button>
            <button onclick="clearNetwork()">üßπ Clear</button>
		</div>

        <div class="layout-controls">
            <button class="toggle-btn active" id="timeline-btn" onclick="setLayout('timeline')">üìÖ Timeline Layout</button>
            <button class="toggle-btn" id="force-btn" onclick="setLayout('force')">üï∏Ô∏è Force Layout</button>
        </div>

        <div id="status" class="status"></div>
        
        <div id="network-container"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Root Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7ed321;"></div>
                <span>Low Citations (1-2)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f5a623;"></div>
                <span>Medium Citations (3-5)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b35;"></div>
                <span>High Citations (6+)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #d0021b;"></div>
                <span>Error/No Date</span>
            </div>
        </div>

        <div class="stats">
            <div id="total-nodes">Total Nodes: 0</div>
            <div id="total-links">Total Links: 0</div>
            <div id="max-depth-reached">Max Depth: 0</div>
            <div id="most-cited">Most Cited: -</div>
            <div id="date-range">Date Range: -</div>
        </div>
    </div>

    <script>
        let networkData = { nodes: [], links: [] };
        let svg = null;
        let simulation = null;
        let tooltip = null;
        let nodeMap = new Map();
        let rootQID = null;
        let currentLayout = 'timeline';
        let timeScale = null;

        // Initialize SVG and simulation
        function initNetwork() {
            const container = d3.select("#network-container");
            container.selectAll("*").remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
                
            // Add zoom functionality
            const g = svg.append("g");
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom);

            // Create tooltip
            if (tooltip) tooltip.remove();
            tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Add arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 8)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#666");

            // Initialize force simulation
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => getNodeSize(d) + 5));

            return { svg, g, width, height };
        }

        // Fetch data from Wikidata SPARQL endpoint with publication dates
        async function fetchQIDData(qid) {
            const sparqlQuery = `
                SELECT ?item ?itemLabel ?cited ?citedLabel ?pubDate ?citedPubDate WHERE {
                    VALUES ?item { wd:${qid} }
                    VALUES ?filtering { wd:Q1643932  wd:Q2164067 wd:Q1472433 }
                    ?item wdt:P31 ?filtering.
                    OPTIONAL { ?item wdt:P577 ?pubDate . }
                    OPTIONAL {
                        ?item wdt:P2860 ?cited .
						?cited wdt:P31 ?filtering.
                        OPTIONAL { ?cited wdt:P577 ?citedPubDate . }
                    }
                    SERVICE wikibase:label { bd:serviceParam wikibase:language "en" . }
                }
            `;
            
            const url = 'https://query.wikidata.org/sparql?' + new URLSearchParams({
                query: sparqlQuery,
                format: 'json'
            });

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const bindings = data.results.bindings;
                
                if (bindings.length === 0) {
                    throw new Error('QID not found or not a TTRPG');
                }

                // Get main item info
                const mainItem = bindings[0];
                const itemInfo = {
                    qid: qid,
                    label: mainItem.itemLabel ? mainItem.itemLabel.value : qid,
                    publicationDate: mainItem.pubDate ? new Date(mainItem.pubDate.value) : null,
                    citations: []
                };

                // Get citations with their publication dates
                const citedItems = new Set();
                bindings.forEach(binding => {
                    if (binding.cited) {
                        const citedQID = binding.cited.value.split('/').pop();
                        const citedLabel = binding.citedLabel ? binding.citedLabel.value : citedQID;
                        const citedPubDate = binding.citedPubDate ? new Date(binding.citedPubDate.value) : null;
                        
                        if (!citedItems.has(citedQID)) {
                            citedItems.add(citedQID);
                            itemInfo.citations.push({
                                qid: citedQID,
                                label: citedLabel,
                                publicationDate: citedPubDate
                            });
                        }
                    }
                });

                return itemInfo;
            } catch (error) {
                console.error(`Error fetching ${qid}:`, error);
                return {
                    qid: qid,
                    label: `${qid} (Error)`,
                    publicationDate: null,
                    citations: [],
                    error: true
                };
            }
        }

        // Build network data structure
        async function buildNetworkData(startQID, maxDepth) {
            const nodes = new Map();
            const links = [];
            const toProcess = [{ qid: startQID, depth: 0 }];
            const processed = new Set();

            while (toProcess.length > 0) {
                const { qid, depth } = toProcess.shift();
                
                if (processed.has(qid) || depth >= maxDepth) {
                    continue;
                }

                processed.add(qid);
                updateStatus(`Processing ${qid} (depth ${depth + 1}/${maxDepth})...`, 'loading');

                const itemData = await fetchQIDData(qid);
                
                if (itemData.error) {
                    continue;
                }

                // Add or update node
                if (!nodes.has(qid)) {
                    nodes.set(qid, {
                        id: qid,
                        label: itemData.label,
                        publicationDate: itemData.publicationDate,
                        year: itemData.publicationDate ? itemData.publicationDate.getFullYear() : null,
                        depth: depth,
                        isRoot: qid === startQID,
                        inDegree: 0,
                        outDegree: itemData.citations.length,
                        citations: itemData.citations,
                        error: false
                    });
                }

                // Add citations to processing queue and create links
                for (const citation of itemData.citations.slice(0, 15)) {
                    // Add cited node if not exists
                    if (!nodes.has(citation.qid)) {
                        nodes.set(citation.qid, {
                            id: citation.qid,
                            label: citation.label,
                            publicationDate: citation.publicationDate,
                            year: citation.publicationDate ? citation.publicationDate.getFullYear() : null,
                            depth: depth + 1,
                            isRoot: false,
                            inDegree: 0,
                            outDegree: 0,
                            citations: [],
                            error: false
                        });
                    }

                    // Create link
                    links.push({
                        source: qid,
                        target: citation.qid,
                        depth: depth
                    });

                    // Increment in-degree
                    nodes.get(citation.qid).inDegree++;

                    // Add to processing queue if within depth limit
                    if (depth + 1 < maxDepth) {
                        toProcess.push({ qid: citation.qid, depth: depth + 1 });
                    }
                }

                // Add delay
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            return {
                nodes: Array.from(nodes.values()),
                links: links
            };
        }

        // Get node color based on citations and dates
        function getNodeColor(node) {
            if (node.error || !node.year) return '#d0021b';
            if (node.isRoot) return '#4a90e2';
            if (node.inDegree >= 6) return '#ff6b35';
            if (node.inDegree >= 3) return '#f5a623';
            return '#7ed321';
        }

        // Get node size based on importance
        function getNodeSize(node) {
            if (node.isRoot) return 12;
            return Math.max(6, Math.sqrt(node.inDegree * 8) + 4);
        }

        // Setup timeline
        function setupTimeline(data, g, width, height) {
            const nodesWithDates = data.nodes.filter(n => n.year);
            if (nodesWithDates.length === 0) return null;
            
            const years = nodesWithDates.map(n => n.year);
            const minYear = Math.min(...years) - 2;
            const maxYear = Math.max(...years) + 2;
            
            timeScale = d3.scaleLinear()
                .domain([minYear, maxYear])
                .range([100, width - 100]);
            
            const timelineGroup = g.append("g").attr("class", "timeline");
            
            // Main timeline axis
            timelineGroup.append("line")
                .attr("class", "timeline-axis")
                .attr("x1", 100)
                .attr("x2", width - 100)
                .attr("y1", height - 60)
                .attr("y2", height - 60);
            
            // Year ticks
            const yearRange = d3.range(
                Math.ceil(minYear / 5) * 5, 
                Math.floor(maxYear / 5) * 5 + 1, 
                5
            );
            
            yearRange.forEach(year => {
                const x = timeScale(year);
                
                timelineGroup.append("line")
                    .attr("class", "timeline-tick")
                    .attr("x1", x).attr("x2", x)
                    .attr("y1", height - 65).attr("y2", height - 55);
                
                timelineGroup.append("text")
                    .attr("class", "timeline-label")
                    .attr("x", x).attr("y", height - 40)
                    .text(year);
            });
            
            // Decade separators
            const decades = d3.range(
                Math.ceil(minYear / 10) * 10,
                Math.floor(maxYear / 10) * 10 + 1,
                10
            );
            
            decades.forEach(decade => {
                const x = timeScale(decade);
                timelineGroup.append("line")
                    .attr("class", "decade-separator")
                    .attr("x1", x).attr("x2", x)
                    .attr("y1", 50).attr("y2", height - 70);
            });
            
            return timeScale;
        }

        // Set layout mode
        function setLayout(layout) {
            currentLayout = layout;
            
            document.getElementById('timeline-btn').classList.toggle('active', layout === 'timeline');
            document.getElementById('force-btn').classList.toggle('active', layout === 'force');
            
            if (networkData.nodes.length === 0) return;
            
            if (layout === 'timeline' && timeScale) {
                // Position nodes by year
                networkData.nodes.forEach(node => {
                    if (node.year) {
                        node.fx = timeScale(node.year);
                        node.fy = null; // Let Y position be determined by forces
                    } else {
                        node.fx = timeScale.range()[1] + 50; // Right side for unknown dates
                        node.fy = null;
                    }
                });
                
                // Adjust forces for timeline
                simulation.force("charge").strength(-100);
                simulation.force("center", null);
            } else {
                // Free positioning
                networkData.nodes.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
                
                // Reset forces
                const container = d3.select("#network-container");
                const width = container.node().getBoundingClientRect().width;
                const height = container.node().getBoundingClientRect().height;
                
                simulation.force("charge").strength(-200);
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }
            
            simulation.alpha(0.5).restart();
        }

        // Visualize network
        function visualizeNetwork(data) {
            const { svg, g, width, height } = initNetwork();

            networkData = data;
            nodeMap.clear();
            data.nodes.forEach(node => nodeMap.set(node.id, node));

            // Setup timeline
            setupTimeline(data, g, width, height);

            // Create links
            const link = g.append("g")
                .selectAll("path")
                .data(data.links)
                .enter().append("path")
                .attr("class", "link")
                .classed("backward-citation", d => {
                    const source = nodeMap.get(d.source);
                    const target = nodeMap.get(d.target);
                    return source?.year && target?.year && source.year > target.year;
                })
                .attr("marker-end", "url(#arrowhead)");

            // Create nodes
            const node = g.append("g")
                .selectAll("g")
                .data(data.nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Add circles
            node.append("circle")
                .attr("r", getNodeSize)
                .style("fill", getNodeColor);

            // Add labels
            node.append("text")
                .attr("dy", d => getNodeSize(d) + 15)
                .style("font-size", "10px")
                .style("font-weight", d => d.inDegree > 2 ? "bold" : "normal")
                .text(d => {
                    const maxLength = 20;
                    let name = d.label.length > maxLength 
                        ? d.label.substring(0, maxLength) + '...' 
                        : d.label;
                    if (d.year) name += ` (${d.year})`;
                    return name;
                });

            // Add interactivity
            node
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", .9);
                    
                    const dateStr = d.year ? d.year.toString() : 'Unknown';
                    let tooltipContent = `
                        <strong>${d.label}</strong><br/>
                        QID: ${d.id}<br/>
                        Published: ${dateStr}<br/>
                        Cited by: ${d.inDegree} nodes<br/>
                        Cites: ${d.outDegree} nodes<br/>
                        Depth: ${d.depth}
                    `;
                    
                    if (d.isRoot) tooltipContent += '<br/><strong>ROOT NODE</strong>';
                    
                    tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                        
                    link.classed("highlighted", l => 
                        (l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id
                    );
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(500).style("opacity", 0);
                    link.classed("highlighted", false);
                })
                .on("click", function(event, d) {
                    window.open(`https://www.wikidata.org/wiki/${d.id}`, '_blank');
                });

            // Update simulation
            simulation
                .nodes(data.nodes)
                .on("tick", () => {
                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = currentLayout === 'timeline' ? Math.sqrt(dx * dx + dy * dy) * 0.3 : 0;
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });

                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });

            simulation.force("link").links(data.links);
            
            // Apply initial layout
            setLayout(currentLayout);
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            if (currentLayout === 'timeline' && d.year && timeScale) {
                d.fx = timeScale(d.year); // Keep X position fixed to timeline
                d.fy = event.y;
            } else {
                d.fx = event.x;
                d.fy = event.y;
            }
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            if (currentLayout !== 'timeline') {
                d.fx = null;
                d.fy = null;
            }
        }

        // Main function to build network
        async function buildNetwork() {
            const qidInput = document.getElementById('qid-input').value.trim();
            const maxDepthInput = parseInt(document.getElementById('max-depth').value) || 4;
            
            if (!qidInput) {
                updateStatus('Please enter a QID', 'error');
                return;
            }

            const qidRegex = /^Q\d+$/i;
            if (!qidRegex.test(qidInput)) {
                updateStatus('Please enter a valid QID format (e.g., Q112134730)', 'error');
                return;
            }

            const qid = qidInput.toUpperCase();
            rootQID = qid;
            
            try {
                updateStatus('Building citation network...', 'loading');
                
                const data = await buildNetworkData(qid, maxDepthInput);
                
                if (data.nodes.length === 0) {
                    updateStatus('No data found', 'error');
                    return;
                }

                visualizeNetwork(data);
                updateStatus(`Network built! ${data.nodes.length} nodes, ${data.links.length} connections`, 'success');
                updateStats(data);
                
            } catch (error) {
                console.error('Error building network:', error);
                updateStatus('Error building network: ' + error.message, 'error');
            }
        }

        // Update status
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Update statistics
        function updateStats(data) {
            const mostCitedNode = data.nodes.reduce((max, node) => 
                node.inDegree > max.inDegree ? node : max, 
                { inDegree: 0, label: 'None' }
            );
            
            const maxDepth = Math.max(...data.nodes.map(n => n.depth));
            const nodesWithDates = data.nodes.filter(n => n.year);
            const dateRange = nodesWithDates.length > 0 
                ? `${Math.min(...nodesWithDates.map(n => n.year))} - ${Math.max(...nodesWithDates.map(n => n.year))}`
                : 'No dates available';

            document.getElementById('total-nodes').textContent = `Total Nodes: ${data.nodes.length}`;
            document.getElementById('total-links').textContent = `Total Links: ${data.links.length}`;
            document.getElementById('max-depth-reached').textContent = `Max Depth: ${maxDepth + 1}`;
            document.getElementById('date-range').textContent = `Date Range: ${dateRange}`;
        }

        // Clear network
        function clearNetwork() {
            d3.select("#network-container").selectAll("*").remove();
            if (tooltip) tooltip.remove();
            if (simulation) simulation.stop();
            networkData = { nodes: [], links: [] };
            nodeMap.clear();
            timeScale = null;
            updateStatus('');
            document.getElementById('total-nodes').textContent = 'Total Nodes: 0';
            document.getElementById('total-links').textContent = 'Total Links: 0';
            document.getElementById('max-depth-reached').textContent = 'Max Depth: 0';
            document.getElementById('most-cited').textContent = 'Most Cited: -';
            document.getElementById('date-range').textContent = 'Date Range: -';
        }

        // Handle Enter key
        document.getElementById('qid-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                buildNetwork();
            }
        });

        // Initialize
        updateStatus('Enter a QID for a TTRPG to start exploring the citation timeline network');
    </script>
	<p>The data is retrieved from Wikidata with the property P2860 (<i>cites</i>) and P577 (<i>publication date</i>). Only TTRPGs, or RPG theories, or RPG systems are retrieved. Toggle between Timeline Layout (chronological positioning) and Force Layout (network physics). Citations flowing backwards in time are highlighted in orange. This tool is based on <a href="">CitationTree</a> by Nicolas Loizeau.</p>
</body>
</html>