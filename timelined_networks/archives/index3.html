<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTRPG Citation Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        input[type="text"] {
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            width: 200px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        button {
            padding: 12px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 10px;
            min-height: 20px;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }

        #network-container {
            width: 100%;
            height: 700px;
            border: 2px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            background: #fafafa;
            position: relative;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .node text {
            font-size: 11px;
            font-family: 'Segoe UI', sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
            fill: none;
        }

        .link.highlighted {
            stroke: #ff6b35;
            stroke-opacity: 0.8;
            stroke-width: 3px;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            word-wrap: break-word;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            flex-wrap: wrap;
        }

        .controls-extra {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 150px;
        }

        .network-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
<div class="container">
        <h1>üï∏Ô∏è TTRPG Citation Network</h1>
        
        <p>Submit the Wikidata QID of a tabletop role-playing game (for example Q112134730 is <i>Apocalypse World, 1st ed.</i>, by Vincent Baker). 
		Then submit the depth of crawling (between 1 and 15, default is 4). Click Build and explore the network of citations between games.</p>
        
        <div class="controls">
            <input type="text" id="qid-input" placeholder="Enter QID (e.g., Q112134730)" value="Q112134730">
            <input type="number" id="max-depth" placeholder="Max depth" min="1" max="15" value="4">
            <button onclick="buildNetwork()">üîç Build Citation Network</button>
            <button onclick="clearNetwork()">üßπ Clear</button>
		</div>

        <div class="network-controls">
            <div class="controls-extra">
                <div class="slider-container">
                    <label>Link Distance:</label>
                    <input type="range" id="link-distance" min="30" max="200" value="80" oninput="updateForces()">
                    <span id="link-distance-value">80</span>
                </div>
                <div class="slider-container">
                    <label>Charge Strength:</label>
                    <input type="range" id="charge-strength" min="-500" max="-50" value="-150" oninput="updateForces()">
                    <span id="charge-strength-value">-150</span>
                </div>
                <button onclick="restartSimulation()">üîÑ Restart Physics</button>
                <button onclick="centerNetwork()">üéØ Center View</button>
            </div>
        </div>

        <div id="status" class="status"></div>
        
        <div id="network-container"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Root Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7ed321;"></div>
                <span>Low Citations (1-2)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f5a623;"></div>
                <span>Medium Citations (3-5)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b35;"></div>
                <span>High Citations (6+)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #d0021b;"></div>
                <span>Error/Not Found</span>
            </div>
        </div>

        <div class="stats">
            <div id="total-nodes">Total Nodes: 0</div>
            <div id="total-links">Total Links: 0</div>
            <div id="max-depth-reached">Max Depth: 0</div>
            <div id="most-cited">Most Cited: -</div>
        </div>
    </div>

    <script>
        let networkData = { nodes: [], links: [] };
        let svg = null;
        let simulation = null;
        let tooltip = null;
        let nodeMap = new Map();
        let rootQID = null;

        // Initialize SVG and simulation
        function initNetwork() {
            const container = d3.select("#network-container");
            container.selectAll("*").remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
                
            // Add zoom functionality
            const g = svg.append("g");
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom);

            // Create tooltip
            if (tooltip) tooltip.remove();
            tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Initialize force simulation
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-150))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => Math.max(8, Math.sqrt(d.inDegree * 3) + 5)));

            return { svg, g, width, height };
        }

        // Fetch data from Wikidata SPARQL endpoint
        async function fetchQIDData(qid) {
            const sparqlQuery = `
                SELECT ?item ?itemLabel ?cited ?citedLabel WHERE {
                    VALUES ?item { wd:${qid} }
                    VALUES ?filtering { wd:Q1643932  wd:Q2164067 wd:Q1472433 }
                    ?item wdt:P31 ?filtering.
                    OPTIONAL {
                        ?item wdt:P2860 ?cited .
                    }
                    SERVICE wikibase:label { bd:serviceParam wikibase:language "en" . }
                }
            `;
            
            const url = 'https://query.wikidata.org/sparql?' + new URLSearchParams({
                query: sparqlQuery,
                format: 'json'
            });

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const bindings = data.results.bindings;
                
                if (bindings.length === 0) {
                    throw new Error('QID not found or not a TTRPG');
                }

                // Get main item info
                const mainItem = bindings[0];
                const itemInfo = {
                    qid: qid,
                    label: mainItem.itemLabel ? mainItem.itemLabel.value : qid,
                    citations: []
                };

                // Get citations
                const citedItems = new Set();
                bindings.forEach(binding => {
                    if (binding.cited) {
                        const citedQID = binding.cited.value.split('/').pop();
                        const citedLabel = binding.citedLabel ? binding.citedLabel.value : citedQID;
                        
                        if (!citedItems.has(citedQID)) {
                            citedItems.add(citedQID);
                            itemInfo.citations.push({
                                qid: citedQID,
                                label: citedLabel
                            });
                        }
                    }
                });

                return itemInfo;
            } catch (error) {
                console.error(`Error fetching ${qid}:`, error);
                return {
                    qid: qid,
                    label: `${qid} (Error)`,
                    citations: [],
                    error: true
                };
            }
        }

        // Build network data structure
        async function buildNetworkData(startQID, maxDepth) {
            const nodes = new Map();
            const links = [];
            const toProcess = [{ qid: startQID, depth: 0 }];
            const processed = new Set();

            while (toProcess.length > 0) {
                const { qid, depth } = toProcess.shift();
                
                if (processed.has(qid) || depth >= maxDepth) {
                    continue;
                }

                processed.add(qid);
                updateStatus(`Processing ${qid} (depth ${depth + 1}/${maxDepth})...`, 'loading');

                const itemData = await fetchQIDData(qid);
                
                if (itemData.error) {
                    continue;
                }

                // Add or update node
                if (!nodes.has(qid)) {
                    nodes.set(qid, {
                        id: qid,
                        label: itemData.label,
                        depth: depth,
                        isRoot: qid === startQID,
                        inDegree: 0,
                        outDegree: itemData.citations.length,
                        citations: itemData.citations,
                        error: false
                    });
                }

                // Add citations to processing queue and create links
                for (const citation of itemData.citations.slice(0, 15)) {
                    // Add cited node if not exists
                    if (!nodes.has(citation.qid)) {
                        nodes.set(citation.qid, {
                            id: citation.qid,
                            label: citation.label,
                            depth: depth + 1,
                            isRoot: false,
                            inDegree: 0,
                            outDegree: 0,
                            citations: [],
                            error: false
                        });
                    }

                    // Create link
                    links.push({
                        source: qid,
                        target: citation.qid,
                        depth: depth
                    });

                    // Increment in-degree
                    nodes.get(citation.qid).inDegree++;

                    // Add to processing queue if within depth limit
                    if (depth + 1 < maxDepth) {
                        toProcess.push({ qid: citation.qid, depth: depth + 1 });
                    }
                }

                // Add delay
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            return {
                nodes: Array.from(nodes.values()),
                links: links
            };
        }

        // Get node color based on in-degree (how many times it's cited)
        function getNodeColor(node) {
            if (node.error) return '#d0021b';
            if (node.isRoot) return '#4a90e2';
            if (node.inDegree >= 6) return '#ff6b35';  // High citations
            if (node.inDegree >= 3) return '#f5a623';  // Medium citations
            return '#7ed321';  // Low citations
        }

        // Get node size based on in-degree
        function getNodeSize(node) {
            if (node.isRoot) return 12;
            return Math.max(6, Math.sqrt(node.inDegree * 8) + 4);
        }

        // Visualize network
        function visualizeNetwork(data) {
            const { svg, g, width, height } = initNetwork();

            networkData = data;
            nodeMap.clear();
            data.nodes.forEach(node => nodeMap.set(node.id, node));

            // Create links
            const link = g.append("g")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("class", "link")
                .style("stroke-width", d => Math.max(1, 3 - d.depth));

            // Create nodes
            const node = g.append("g")
                .selectAll("g")
                .data(data.nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Add circles
            node.append("circle")
                .attr("r", getNodeSize)
                .style("fill", getNodeColor);

            // Add labels
            node.append("text")
                .attr("dy", d => getNodeSize(d) + 15)
                .style("font-size", d => `${Math.max(9, Math.min(12, getNodeSize(d)))}px`)
                .style("font-weight", d => d.inDegree > 2 ? "bold" : "normal")
                .text(d => {
                    const maxLength = d.inDegree > 3 ? 25 : 15;
                    return d.label.length > maxLength 
                        ? d.label.substring(0, maxLength) + '...' 
                        : d.label;
                });

            // Add interactivity
            node
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", .9);
                    
                    let tooltipContent = `
                        <strong>${d.label}</strong><br/>
                        QID: ${d.id}<br/>
                        Cited by: ${d.inDegree} nodes<br/>
                        Cites: ${d.outDegree} nodes<br/>
                        Depth: ${d.depth}
                    `;
                    
                    if (d.isRoot) tooltipContent += '<br/><strong>ROOT NODE</strong>';
                    
                    tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                        
                    // Highlight connected links
                    link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id);
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(500).style("opacity", 0);
                    link.classed("highlighted", false);
                })
                .on("click", function(event, d) {
                    window.open(`https://www.wikidata.org/wiki/${d.id}`, '_blank');
                });

            // Update simulation
            simulation
                .nodes(data.nodes)
                .on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });

            simulation.force("link").links(data.links);
            simulation.alpha(1).restart();
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Update force parameters
        function updateForces() {
            if (!simulation) return;
            
            const linkDistance = document.getElementById('link-distance').value;
            const chargeStrength = document.getElementById('charge-strength').value;
            
            document.getElementById('link-distance-value').textContent = linkDistance;
            document.getElementById('charge-strength-value').textContent = chargeStrength;
            
            simulation.force("link").distance(linkDistance);
            simulation.force("charge").strength(chargeStrength);
            simulation.alpha(0.3).restart();
        }

        // Restart simulation
        function restartSimulation() {
            if (simulation) {
                simulation.alpha(1).restart();
            }
        }

        // Center network view
        function centerNetwork() {
            if (!svg || networkData.nodes.length === 0) return;
            
            const container = d3.select("#network-container");
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity.translate(width / 2, height / 2).scale(1)
            );
        }

        // Main function to build network
        async function buildNetwork() {
            const qidInput = document.getElementById('qid-input').value.trim();
            const maxDepthInput = parseInt(document.getElementById('max-depth').value) || 4;
            
            if (!qidInput) {
                updateStatus('Please enter a QID', 'error');
                return;
            }

            const qidRegex = /^Q\d+$/i;
            if (!qidRegex.test(qidInput)) {
                updateStatus('Please enter a valid QID format (e.g., Q112134730)', 'error');
                return;
            }

            const qid = qidInput.toUpperCase();
            rootQID = qid;
            
            try {
                updateStatus('Building citation network...', 'loading');
                
                const data = await buildNetworkData(qid, maxDepthInput);
                
                if (data.nodes.length === 0) {
                    updateStatus('No data found', 'error');
                    return;
                }

                visualizeNetwork(data);
                updateStatus(`Network built! ${data.nodes.length} nodes, ${data.links.length} connections`, 'success');
                updateStats(data);
                
            } catch (error) {
                console.error('Error building network:', error);
                updateStatus('Error building network: ' + error.message, 'error');
            }
        }

        // Update status
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Update statistics
        function updateStats(data) {
            const mostCitedNode = data.nodes.reduce((max, node) => 
                node.inDegree > max.inDegree ? node : max, 
                { inDegree: 0, label: 'None' }
            );
            
            const maxDepth = Math.max(...data.nodes.map(n => n.depth));

            document.getElementById('total-nodes').textContent = `Total Nodes: ${data.nodes.length}`;
            document.getElementById('total-links').textContent = `Total Links: ${data.links.length}`;
            document.getElementById('max-depth-reached').textContent = `Max Depth: ${maxDepth + 1}`;
            document.getElementById('most-cited').textContent = `Most Cited: ${mostCitedNode.label} (${mostCitedNode.inDegree})`;
        }

        // Clear network
        function clearNetwork() {
            d3.select("#network-container").selectAll("*").remove();
            if (tooltip) tooltip.remove();
            if (simulation) simulation.stop();
            networkData = { nodes: [], links: [] };
            nodeMap.clear();
            updateStatus('');
            document.getElementById('total-nodes').textContent = 'Total Nodes: 0';
            document.getElementById('total-links').textContent = 'Total Links: 0';
            document.getElementById('max-depth-reached').textContent = 'Max Depth: 0';
            document.getElementById('most-cited').textContent = 'Most Cited: -';
        }

        // Handle Enter key
        document.getElementById('qid-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                buildNetwork();
            }
        });

        // Initialize
        updateStatus('Enter a QID for a TTRPG to start exploring the citation network');
    </script>
	<p>The data is retrieved from Wikidata with the property P2860 (<i>cites</i>). Only TTRPGs, or RPG theories, or RPG systems are retrieved. This shows the true network structure with multiple edges to popular nodes. Use the controls to adjust the physics simulation. This tool is based on <a href="">CitationTree</a> by Nicolas Loizeau.</p>
</body>
</html>