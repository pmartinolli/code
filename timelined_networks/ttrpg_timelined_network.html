<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTRPG Citation Timeline</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .advanced-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            font-weight: bold;
            min-width: 120px;
            color: #555;
            margin-top: 12px;
        }

        input[type="text"] {
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            width: 200px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        .property-input {
            width: 80px;
        }

        textarea {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 14px;
            width: 350px;
            font-family: monospace;
            resize: vertical;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        button {
            padding: 12px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preset-btn {
            padding: 6px 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 10px;
            min-height: 20px;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }

        #network-container {
            width: 100%;
            height: 800px;
            border: 2px solid #ddd;
            border-radius: 15px;
            overflow: hidden;
            background: #fafafa;
            position: relative;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .node text {
            font-size: 11px;
            font-family: 'Segoe UI', sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            fill: none;
        }

        .link.highlighted {
            stroke: #ff6b35;
            stroke-opacity: 0.8;
            stroke-width: 2px;
        }

        .link.backward-citation {
            stroke: #ff6b35;
            stroke-opacity: 0.8;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            word-wrap: break-word;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            flex-wrap: wrap;
        }

        .layout-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            border-radius: 20px;
            background: white;
            color: #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: #667eea;
            color: white;
        }

        .timeline-axis {
            stroke: #666;
            stroke-width: 2;
        }

        .timeline-tick {
            stroke: #999;
            stroke-width: 1;
        }

        .timeline-label {
            font-size: 12px;
            fill: #666;
            text-anchor: middle;
        }

        .decade-separator {
            stroke: #ddd;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-left: 10px;
            font-style: italic;
            flex: 1;
        }
    </style>
</head>
<body>
<div class="container">
        <h1>TTRPG Timelined Citation Network</h1>
        
        <p>This in-browser script retrieves and displays on a timeline all the backward citation network of a starting tabletop role-playing game element. By default, discover how <i>Apocalypse World 1st edition</i> by Vincent D. Baker and Meguey Baker is acknowledging inspirations, tributes, hommages, etc. within its rules. 
        </p>
        
            <div class="control-group">
                <label>Quick presets:</label>
				<button class="preset-btn" onclick="setPreset('apocalypseworld')">Apocalypse World 1st ed.</button>
				<button class="preset-btn" onclick="setPreset('runequest')">Runequest (misc. editions)</button>
				<button class="preset-btn" onclick="setPreset('dndholmes')">D&D Holmes</button>
				<button class="preset-btn" onclick="setPreset('dnd5')">D&D 5th ed.</button>
            </div>
            <div class="control-group">
                <label>Relation Property:</label>
                <input type="text" id="citation-property" class="property-input" value="P2860" placeholder="P2860">
                <span class="help-text">Choose a Wikidata Property for relations (default: P2860 "cites work")</span>

                <label>Only retrieve this Types:</label>
                <textarea id="filter-types" rows="3" placeholder="Q1643932, Q2164067, Q1472433">Q1643932, Q2164067, Q1472433</textarea>
                <span class="help-text">Instance of (P31) entity types to include as QIDs separated by comma, space, or line breaks (default : TTRPG, TTRPG systems, TTRPG theory).</span>
            </div>
            


            <div class="control-group">
                <label>Starting QID of a TTRPG:</label>
                <input type="text" id="qid-input" placeholder="Enter starting QID" value="Q112134730">
                <span class="help-text">(Root of the network to build)</span>
                <label>Depth of crawling:</label>
                <input type="number" id="max-depth" placeholder="Max depth" min="1" max="15" value="2">
                <button onclick="buildNetwork()">üîç Build Network</button>
                <button onclick="clearNetwork()">üßπ Clear</button>
            </div>

        <div id="status" class="status"></div>

        <div class="layout-controls">
            <button class="toggle-btn active" id="timeline-btn" onclick="setLayout('timeline')">üìÖ Timeline Layout</button>
            <button class="toggle-btn" id="force-btn" onclick="setLayout('force')">üï∏Ô∏è Force Layout</button>
        </div>


        
        <div id="network-container"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Root Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7ed321;"></div>
                <span>Low Citations (1-2)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f5a623;"></div>
                <span>Medium Citations (3-5)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b35;"></div>
                <span>High Citations (6+)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #d0021b;"></div>
                <span>Error/No Date</span>
            </div>
        </div>

        <div class="stats">
            <div id="total-nodes">Total Nodes: 0</div>
            <div id="total-links">Total Links: 0</div>
            <div id="max-depth-reached">Max Depth: 0</div>
            <div id="most-cited">Most Cited: -</div>
            <div id="date-range">Date Range: -</div>
        </div>
		<p></p>
		<p>The data is retrieved from Wikidata using customizable properties and entity types. Use the presets 
		for common configurations or customize your own. Toggle between Timeline Layout (chronological positioning) 
		and Force Layout (network physics). <br>
		Citations flowing backwards in time are highlighted in orange. Citations flowing onward are colored grey and they are a bug in the data. Indeed, some TTRPGs list citations for all their editions combined, while others only include citations for specific editions (which can sometimes lead to references pointing to works published later). Contributions to improve this data on Wikidata are always welcome. Ideally, citations should be indexed at the edition level rather than merging all citations under a single element‚Äîa mistake I made early in the project and have been working to correct ever since. Single edition games are the easiest to index since I consider them as one element only.</p>
		<p>This tool is based on <a href="https://www.citationtree.org/">CitationTree</a> by Nicolas Loizeau, and <a href="https://www.entitree.com/">EntiTree</a> by Orlando Groppo & Martin Schibel.<br>
		The JavaScript code can be (quite) easily adapted to other needs. If you do so, thank you for citing with something like this : 
		Martinolli, Pascal. 2025. TTRPG Timelined Citation Network ¬ª. JavaScript and Wikidata. 
		Part of <i><a href="https://pmartinolli.github.io/#tabletop-role-playing-games-studies">On the Shoulders of Cloud Giants</a></i> project. </p>
		
    </div>

    <script>
        let networkData = { nodes: [], links: [] };
        let svg = null;
        let simulation = null;
        let tooltip = null;
        let nodeMap = new Map();
        let rootQID = null;
        let currentLayout = 'timeline';
        let timeScale = null;

        // Set preset configurations
        function setPreset(type) {
            switch(type) {
                case 'apocalypseworld':
                    document.getElementById('qid-input').value = 'Q112134730';
                    document.getElementById('citation-property').value = 'P2860';
                    document.getElementById('filter-types').value = 'Q1643932, Q2164067, Q1472433';
                    break;
                case 'runequest':
                    document.getElementById('qid-input').value = 'Q681338';
                    document.getElementById('citation-property').value = 'P2860';
                    document.getElementById('filter-types').value = 'Q1643932, Q2164067, Q1472433';
                    break;
                case 'dndholmes':
                    document.getElementById('qid-input').value = 'Q64596999';
                    document.getElementById('citation-property').value = 'P2860'; 
                    document.getElementById('filter-types').value = 'Q1643932, Q2164067, Q1472433';
                    break;
                case 'dnd5':
                    document.getElementById('qid-input').value = 'Q64706124';
                    document.getElementById('citation-property').value = 'P2860';
                    document.getElementById('filter-types').value = 'Q1643932, Q2164067, Q1472433'; 
                    break;
            }
            updateStatus(`Applied ${type} preset configuration`, 'success');
        }

        // Get current configuration from form
        function getCurrentConfig() {
            const filterTypesText = document.getElementById('filter-types').value.trim();
            
            // Parse QIDs from text area (support comma, space, or line break separation)
            const filterTypes = filterTypesText
                .split(/[,\s\n]+/)
                .map(qid => qid.trim())
                .filter(qid => qid && /^Q\d+$/i.test(qid));
            
            return {
                citationProperty: document.getElementById('citation-property').value.trim() || 'P2860',
                filterTypes: filterTypes
            };
        }

        // Initialize SVG and simulation
        function initNetwork() {
            const container = d3.select("#network-container");
            container.selectAll("*").remove();
            
            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            
            svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
                
            // Add zoom functionality
            const g = svg.append("g");
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom);

            // Create tooltip
            if (tooltip) tooltip.remove();
            tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Add arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 8)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#666");

            // Initialize force simulation
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => getNodeSize(d) + 5));

            return { svg, g, width, height };
        }

        // Fetch data from Wikidata SPARQL endpoint with customizable properties
        async function fetchQIDData(qid) {
            const config = getCurrentConfig();
            
            if (config.filterTypes.length === 0) {
                throw new Error('Please specify at least one filter type (QID)');
            }

            const filterTypesValues = config.filterTypes.map(type => `wd:${type}`).join(' ');
            
            const sparqlQuery = `
                SELECT ?item ?itemLabel ?cited ?citedLabel ?pubDate ?citedPubDate WHERE {
                    VALUES ?item { wd:${qid} }
                    VALUES ?filtering { ${filterTypesValues} }
                    ?item wdt:P31 ?filtering.
                    OPTIONAL { ?item wdt:P577 ?pubDate . }
                    OPTIONAL { ?item wdt:P571 ?incDate . }
                    BIND(
                            IF(BOUND(?pubDate) && BOUND(?incDate),
                                IF(?pubDate < ?incDate, ?pubDate, ?incDate),
                                COALESCE(?pubDate, ?incDate)
                            ) AS ?pubDate
                        )
                    OPTIONAL {
                        ?item wdt:${config.citationProperty} ?cited .
                        ?cited wdt:P31 ?filtering.
                        OPTIONAL { ?cited wdt:P577 ?citedPubDate . }
                        OPTIONAL { ?cited wdt:P571 ?citedIncDate . }
                        BIND(
                                IF(BOUND(?citedPubDate) && BOUND(?citedIncDate),
                                    IF(?citedPubDate < ?citedIncDate, ?citedPubDate, ?citedIncDate),
                                    COALESCE(?citedPubDate, ?citedIncDate)
                                ) AS ?citedPubDate
                            )
                    }
                    SERVICE wikibase:label { bd:serviceParam wikibase:language "en" . }
                }
            `;

            const url = 'https://query.wikidata.org/sparql?' + new URLSearchParams({
                query: sparqlQuery,
                format: 'json'
            });

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const bindings = data.results.bindings;
                
                if (bindings.length === 0) {
                    throw new Error('QID not found or does not match filter criteria');
                }

                // Get main item info
                const mainItem = bindings[0];
                const itemInfo = {
                    qid: qid,
                    label: mainItem.itemLabel ? mainItem.itemLabel.value : qid,
                    publicationDate: mainItem.pubDate ? new Date(mainItem.pubDate.value) : null,
                    citations: []
                };

                // Get citations with their publication dates
                const citedItems = new Set();
                bindings.forEach(binding => {
                    if (binding.cited) {
                        const citedQID = binding.cited.value.split('/').pop();
                        const citedLabel = binding.citedLabel ? binding.citedLabel.value : citedQID;
                        const citedPubDate = binding.citedPubDate ? new Date(binding.citedPubDate.value) : null;
                        
                        if (!citedItems.has(citedQID)) {
                            citedItems.add(citedQID);
                            itemInfo.citations.push({
                                qid: citedQID,
                                label: citedLabel,
                                publicationDate: citedPubDate
                            });
                        }
                    }
                });

                return itemInfo;
            } catch (error) {
                console.error(`Error fetching ${qid}:`, error);
                return {
                    qid: qid,
                    label: `${qid} (Error)`,
                    publicationDate: null,
                    citations: [],
                    error: true
                };
            }
        }

        // Build network data structure
        async function buildNetworkData(startQID, maxDepth) {
            const nodes = new Map();
            const links = [];
            const toProcess = [{ qid: startQID, depth: 0 }];
            const processed = new Set();

            while (toProcess.length > 0) {
                const { qid, depth } = toProcess.shift();
                
                if (processed.has(qid) || depth >= maxDepth) {
                    continue;
                }

                processed.add(qid);
                updateStatus(`Processing ${qid} (depth ${depth + 1}/${maxDepth})...`, 'loading');

                const itemData = await fetchQIDData(qid);
                
                if (itemData.error) {
                    continue;
                }

                // Add or update node
                if (!nodes.has(qid)) {
                    nodes.set(qid, {
                        id: qid,
                        label: itemData.label,
                        publicationDate: itemData.publicationDate,
                        year: itemData.publicationDate ? itemData.publicationDate.getFullYear() : null,
                        depth: depth,
                        isRoot: qid === startQID,
                        inDegree: 0,
                        outDegree: itemData.citations.length,
                        citations: itemData.citations,
                        error: false
                    });
                }

                // Add citations to processing queue and create links
                for (const citation of itemData.citations.slice(0, 15)) {
                    // Add cited node if not exists
                    if (!nodes.has(citation.qid)) {
                        nodes.set(citation.qid, {
                            id: citation.qid,
                            label: citation.label,
                            publicationDate: citation.publicationDate,
                            year: citation.publicationDate ? citation.publicationDate.getFullYear() : null,
                            depth: depth + 1,
                            isRoot: false,
                            inDegree: 0,
                            outDegree: 0,
                            citations: [],
                            error: false
                        });
                    }

                    // Create link
                    links.push({
                        source: qid,
                        target: citation.qid,
                        depth: depth
                    });

                    // Increment in-degree
                    nodes.get(citation.qid).inDegree++;

                    // Add to processing queue if within depth limit
                    if (depth + 1 < maxDepth) {
                        toProcess.push({ qid: citation.qid, depth: depth + 1 });
                    }
                }

                // Add delay
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            return {
                nodes: Array.from(nodes.values()),
                links: links
            };
        }

        // Get node color based on citations and dates
        function getNodeColor(node) {
            if (node.error || !node.year) return '#d0021b';
            if (node.isRoot) return '#4a90e2';
            if (node.inDegree >= 6) return '#ff6b35';
            if (node.inDegree >= 3) return '#f5a623';
            return '#7ed321';
        }

        // Get node size based on importance
        function getNodeSize(node) {
            if (node.isRoot) return 12;
            return Math.max(6, Math.sqrt(node.inDegree * 8) + 4);
        }

        // Setup timeline
        function setupTimeline(data, g, width, height) {
            const nodesWithDates = data.nodes.filter(n => n.year);
            if (nodesWithDates.length === 0) return null;
            
            const years = nodesWithDates.map(n => n.year);
            const minYear = Math.min(...years) - 2;
            const maxYear = Math.max(...years) + 2;
            
            timeScale = d3.scaleLinear()
                .domain([minYear, maxYear])
                .range([100, width - 100]);
            
            const timelineGroup = g.append("g").attr("class", "timeline");
            
            // Main timeline axis
            timelineGroup.append("line")
                .attr("class", "timeline-axis")
                .attr("x1", 100)
                .attr("x2", width - 100)
                .attr("y1", height - 60)
                .attr("y2", height - 60);
            
            // Year ticks
            const yearRange = d3.range(
                Math.ceil(minYear / 5) * 5, 
                Math.floor(maxYear / 5) * 5 + 1, 
                5
            );
            
            yearRange.forEach(year => {
                const x = timeScale(year);
                
                timelineGroup.append("line")
                    .attr("class", "timeline-tick")
                    .attr("x1", x).attr("x2", x)
                    .attr("y1", height - 65).attr("y2", height - 55);
                
                timelineGroup.append("text")
                    .attr("class", "timeline-label")
                    .attr("x", x).attr("y", height - 40)
                    .text(year);
            });
            
            // Decade separators
            const decades = d3.range(
                Math.ceil(minYear / 10) * 10,
                Math.floor(maxYear / 10) * 10 + 1,
                10
            );
            
            decades.forEach(decade => {
                const x = timeScale(decade);
                timelineGroup.append("line")
                    .attr("class", "decade-separator")
                    .attr("x1", x).attr("x2", x)
                    .attr("y1", 50).attr("y2", height - 70);
            });
            
            return timeScale;
        }

        // Set layout mode
        function setLayout(layout) {
            currentLayout = layout;
            
            document.getElementById('timeline-btn').classList.toggle('active', layout === 'timeline');
            document.getElementById('force-btn').classList.toggle('active', layout === 'force');
            
            if (networkData.nodes.length === 0) return;
            
            if (layout === 'timeline' && timeScale) {
                // Position nodes by year
                networkData.nodes.forEach(node => {
                    if (node.year) {
                        node.fx = timeScale(node.year);
                        node.fy = null; // Let Y position be determined by forces
                    } else {
                        node.fx = timeScale.range()[1] + 50; // Right side for unknown dates
                        node.fy = null;
                    }
                });
                
                // Adjust forces for timeline
                simulation.force("charge").strength(-100);
                simulation.force("center", null);
            } else {
                // Free positioning
                networkData.nodes.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
                
                // Reset forces
                const container = d3.select("#network-container");
                const width = container.node().getBoundingClientRect().width;
                const height = container.node().getBoundingClientRect().height;
                
                simulation.force("charge").strength(-200);
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }
            
            simulation.alpha(0.5).restart();
        }

        // Visualize network
        function visualizeNetwork(data) {
            const { svg, g, width, height } = initNetwork();

            networkData = data;
            nodeMap.clear();
            data.nodes.forEach(node => nodeMap.set(node.id, node));

            // Setup timeline
            setupTimeline(data, g, width, height);

            // Create links
            const link = g.append("g")
                .selectAll("path")
                .data(data.links)
                .enter().append("path")
                .attr("class", "link")
                .classed("backward-citation", d => {
                    const source = nodeMap.get(d.source);
                    const target = nodeMap.get(d.target);
                    return source?.year && target?.year && source.year > target.year;
                })
                .attr("marker-end", "url(#arrowhead)");

            // Create nodes
            const node = g.append("g")
                .selectAll("g")
                .data(data.nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Add circles
            node.append("circle")
                .attr("r", getNodeSize)
                .style("fill", getNodeColor);

            // Add labels
            node.append("text")
                .attr("dy", d => getNodeSize(d) + 15)
                .style("font-size", "10px")
                .style("font-weight", d => d.inDegree > 2 ? "bold" : "normal")
                .text(d => {
                    const maxLength = 20;
                    let name = d.label.length > maxLength 
                        ? d.label.substring(0, maxLength) + '...' 
                        : d.label;
                    if (d.year) name += ` (${d.year})`;
                    return name;
                });

            // Add interactivity
            node
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", .9);
                    
                    const dateStr = d.year ? d.year.toString() : 'Unknown';
                    let tooltipContent = `
                        <strong>${d.label}</strong><br/>
                        QID: ${d.id}<br/>
                        Published: ${dateStr}<br/>
                        Cited by: ${d.inDegree} nodes<br/>
                        Cites: ${d.outDegree} nodes<br/>
                        Depth: ${d.depth}
                    `;
                    
                    if (d.isRoot) tooltipContent += '<br/><strong>ROOT NODE</strong>';
                    
                    tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                        
                    link.classed("highlighted", l => 
                        (l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id
                    );
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(500).style("opacity", 0);
                    link.classed("highlighted", false);
                })
                .on("click", function(event, d) {
                    window.open(`https://www.wikidata.org/wiki/${d.id}`, '_blank');
                });

            // Update simulation
            simulation
                .nodes(data.nodes)
                .on("tick", () => {
                    link.attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = currentLayout === 'timeline' ? Math.sqrt(dx * dx + dy * dy) * 0.3 : 0;
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });

                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });

            simulation.force("link").links(data.links);
            
            // Apply initial layout
            setLayout(currentLayout);
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            if (currentLayout === 'timeline' && d.year && timeScale) {
                d.fx = timeScale(d.year); // Keep X position fixed to timeline
                d.fy = event.y;
            } else {
                d.fx = event.x;
                d.fy = event.y;
            }
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            if (currentLayout !== 'timeline') {
                d.fx = null;
                d.fy = null;
            }
        }

        // Main function to build network
        async function buildNetwork() {
            const qidInput = document.getElementById('qid-input').value.trim();
            const maxDepthInput = parseInt(document.getElementById('max-depth').value) || 4;
            
            if (!qidInput) {
                updateStatus('Please enter a QID', 'error');
                return;
            }

            const qidRegex = /^Q\d+$/i;
            if (!qidRegex.test(qidInput)) {
                updateStatus('Please enter a valid QID format (e.g., Q112134730)', 'error');
                return;
            }

            // Validate configuration
            const config = getCurrentConfig();
            if (!config.citationProperty || !/^P\d+$/i.test(config.citationProperty)) {
                updateStatus('Please enter a valid citation property (e.g., P2860)', 'error');
                return;
            }

            if (config.filterTypes.length === 0) {
                updateStatus('Please enter at least one filter type QID', 'error');
                return;
            }

            const qid = qidInput.toUpperCase();
            rootQID = qid;
            
            try {
                updateStatus('Building citation network...', 'loading');
                
                const data = await buildNetworkData(qid, maxDepthInput);
                
                if (data.nodes.length === 0) {
                    updateStatus('No data found with current configuration', 'error');
                    return;
                }

                visualizeNetwork(data);
                updateStatus(`Network built! ${data.nodes.length} nodes, ${data.links.length} connections`, 'success');
                updateStats(data);
                
            } catch (error) {
                console.error('Error building network:', error);
                updateStatus('Error building network: ' + error.message, 'error');
            }
        }

        // Update status
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Update statistics
        function updateStats(data) {
            const mostCitedNode = data.nodes.reduce((max, node) => 
                node.inDegree > max.inDegree ? node : max, 
                { inDegree: 0, label: 'None' }
            );
            
            const maxDepth = Math.max(...data.nodes.map(n => n.depth));
            const nodesWithDates = data.nodes.filter(n => n.year);
            const dateRange = nodesWithDates.length > 0 
                ? `${Math.min(...nodesWithDates.map(n => n.year))} - ${Math.max(...nodesWithDates.map(n => n.year))}`
                : 'No dates available';

            document.getElementById('total-nodes').textContent = `Total Nodes: ${data.nodes.length}`;
            document.getElementById('total-links').textContent = `Total Links: ${data.links.length}`;
            document.getElementById('max-depth-reached').textContent = `Max Depth: ${maxDepth + 1}`;
            document.getElementById('most-cited').textContent = `Most Cited: ${mostCitedNode.label} (${mostCitedNode.inDegree})`;
            document.getElementById('date-range').textContent = `Date Range: ${dateRange}`;
        }

        // Clear network
        function clearNetwork() {
            d3.select("#network-container").selectAll("*").remove();
            if (tooltip) tooltip.remove();
            if (simulation) simulation.stop();
            networkData = { nodes: [], links: [] };
            nodeMap.clear();
            timeScale = null;
            updateStatus('');
            document.getElementById('total-nodes').textContent = 'Total Nodes: 0';
            document.getElementById('total-links').textContent = 'Total Links: 0';
            document.getElementById('max-depth-reached').textContent = 'Max Depth: 0';
            document.getElementById('most-cited').textContent = 'Most Cited: -';
            document.getElementById('date-range').textContent = 'Date Range: -';
        }

        // Handle Enter key
        document.getElementById('qid-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                buildNetwork();
            }
        });

        // Initialize with TTRPG preset
        setPreset('apocalypseworld');
        updateStatus('Enter a preset or your own configuration as needed');
    </script>

</body>
</html>